{"ast":null,"code":"// src/css.ts\nvar css = () => {\n  throw new Error('Using the \"css\" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly.');\n};\nvar css_default = css;\n\n// src/cx.ts\nvar cx = function cx2() {\n  const presentClassNames = Array.prototype.slice.call(arguments).filter(Boolean);\n  const atomicClasses = {};\n  const nonAtomicClasses = [];\n  presentClassNames.forEach(arg => {\n    const individualClassNames = arg ? arg.split(\" \") : [];\n    individualClassNames.forEach(className => {\n      if (className.startsWith(\"atm_\")) {\n        const [, keyHash] = className.split(\"_\");\n        atomicClasses[keyHash] = className;\n      } else {\n        nonAtomicClasses.push(className);\n      }\n    });\n  });\n  const result = [];\n  for (const keyHash in atomicClasses) {\n    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {\n      result.push(atomicClasses[keyHash]);\n    }\n  }\n  result.push(...nonAtomicClasses);\n  return result.join(\" \");\n};\nvar cx_default = cx;\nexport { css_default as css, cx_default as cx };","map":{"version":3,"mappings":";AAUA,IAAMA,MAAW,MAAM;EACrB,MAAM,IAAIC,MACR,yGACF;AACF;AAEA,IAAOC,cAAQF;;;ACMf,IAAMG,KAAU,SAASA,MAAK;EAC5B,MAAMC,oBACJC,MAAMC,UAAUC,MAEbC,KAAKC,SAAS,EACdC,OAAOC,OAAO;EAEnB,MAAMC,gBAAyC,CAAC;EAChD,MAAMC,mBAA6B,EAAC;EACpCT,kBAAkBU,QAASC,OAAQ;IAEjC,MAAMC,uBAAuBD,MAAMA,IAAIE,MAAM,GAAG,IAAI,EAAC;IAErDD,qBAAqBF,QAASI,aAAc;MAC1C,IAAIA,UAAUC,WAAW,MAAM,GAAG;QAChC,MAAM,GAAGC,OAAO,IAAIF,UAAUD,MAAM,GAAG;QACvCL,cAAcQ,WAAWF;MAC3B,OAAO;QACLL,iBAAiBQ,KAAKH,SAAS;MACjC;IACF,CAAC;EACH,CAAC;EAED,MAAMI,SAAmB,EAAC;EAG1B,WAAWF,WAAWR,eAAe;IACnC,IAAIW,OAAOjB,UAAUkB,eAAehB,KAAKI,eAAeQ,OAAO,GAAG;MAChEE,OAAOD,KAAKT,cAAcQ,QAAQ;IACpC;EACF;EAEAE,OAAOD,KAAK,GAAGR,gBAAgB;EAE/B,OAAOS,OAAOG,KAAK,GAAG;AACxB;AAEA,IAAOC,aAAQvB","names":["css","Error","css_default","cx","presentClassNames","Array","prototype","slice","call","arguments","filter","Boolean","atomicClasses","nonAtomicClasses","forEach","arg","individualClassNames","split","className","startsWith","keyHash","push","result","Object","hasOwnProperty","join","cx_default"],"sources":["/Users/hanauchiakiya/GitHub/re-Think/node_modules/@linaria/core/src/css.ts","/Users/hanauchiakiya/GitHub/re-Think/node_modules/@linaria/core/src/cx.ts"],"sourcesContent":["import type { StyledMeta } from '@linaria/tags';\n\nimport type { CSSProperties } from './CSSProperties';\nimport type { LinariaClassName } from './cx';\n\ntype CSS = (\n  strings: TemplateStringsArray,\n  ...exprs: Array<string | number | CSSProperties | StyledMeta>\n) => LinariaClassName;\n\nconst css: CSS = () => {\n  throw new Error(\n    'Using the \"css\" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly.'\n  );\n};\n\nexport default css;\n","export type LinariaClassName = string & { __linariaClassName: true };\n\nexport type ClassName<T = string> = T | false | void | null | 0 | '';\n\ninterface ICX {\n  (...classNames: ClassName<LinariaClassName>[]): LinariaClassName;\n  (...classNames: ClassName[]): string;\n}\n/**\n * Takes a list of class names and filters for truthy ones, joining them into a single class name for convenience.\n * eg.\n * ```js\n *  cx('red', isBig && 'big') // returns 'red big' if `isBig` is true, otherwise returns 'red'\n * ```\n * If space separated atomic styles are provided, they are deduplicated according to the first hashed valued:\n *\n * ```js\n *  cx('atm_a_class1 atm_b_class2', 'atm_a_class3') // returns `atm_a_class3 atm_b_class2`\n * ```\n *\n * @returns the combined, space separated class names that can be applied directly to the class attribute\n */\nconst cx: ICX = function cx() {\n  const presentClassNames: (ClassName | ClassName<LinariaClassName>)[] =\n    Array.prototype.slice\n      // eslint-disable-next-line prefer-rest-params\n      .call(arguments)\n      .filter(Boolean);\n\n  const atomicClasses: { [k: string]: string } = {};\n  const nonAtomicClasses: string[] = [];\n  presentClassNames.forEach((arg) => {\n    // className could be the output of a previous cx call, so split by ' ' first\n    const individualClassNames = arg ? arg.split(' ') : [];\n\n    individualClassNames.forEach((className) => {\n      if (className.startsWith('atm_')) {\n        const [, keyHash] = className.split('_');\n        atomicClasses[keyHash] = className;\n      } else {\n        nonAtomicClasses.push(className);\n      }\n    });\n  });\n\n  const result: string[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const keyHash in atomicClasses) {\n    if (Object.prototype.hasOwnProperty.call(atomicClasses, keyHash)) {\n      result.push(atomicClasses[keyHash]);\n    }\n  }\n\n  result.push(...nonAtomicClasses);\n\n  return result.join(' ') as LinariaClassName;\n};\n\nexport default cx;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}