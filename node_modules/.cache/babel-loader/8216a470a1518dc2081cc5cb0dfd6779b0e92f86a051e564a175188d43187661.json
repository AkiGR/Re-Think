{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    classNames[_key - 1] = arguments[_key];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\nfunction removeClassNamesFromElement(element) {\n  for (var _len2 = arguments.length, classNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classNames[_key2 - 1] = arguments[_key2];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\nfunction mergeRegister() {\n  for (var _len3 = arguments.length, func = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    func[_key3] = arguments[_key3];\n  }\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map(editorState._nodeMap);\n  const activeEditorState = editor._pendingEditorState;\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  lexical.$setSelection(selection === null ? null : selection.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!lexical.$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = lexical.$isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : lexical.$copyNode(currentNode);\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$splitNode = $splitNode;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;","map":{"version":3,"names":["lexical","require","addClassNamesToElement","element","classNames","forEach","className","classesToAdd","split","filter","n","classList","add","removeClassNamesFromElement","remove","isMimeType","file","acceptableMimeTypes","acceptableType","type","startsWith","mediaFileReader","files","filesIterator","Symbol","iterator","Promise","resolve","reject","processed","handleNextFile","done","value","next","fileReader","FileReader","addEventListener","result","push","readAsDataURL","$dfs","startingNode","endingNode","nodes","start","$getRoot","getLatest","end","$isElementNode","getLastDescendant","node","depth","$getDepth","is","getChildrenSize","getFirstChild","sibling","getNextSibling","getParent","innerNode","$getNearestNodeOfType","klass","parent","$getNearestBlockElementAncestorOrThrow","startNode","blockNode","$findMatchingParent","isInline","Error","__key","findFn","curr","mergeRegister","func","f","registerNestedElementResolver","editor","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","i","length","child","parentNode","childNode","elementNodeTransform","match","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","append","canBeEmpty","registerNodeTransform","$restoreEditorState","editorState","FULL_RECONCILE","nodeMap","Map","_nodeMap","activeEditorState","_pendingEditorState","_dirtyType","selection","_selection","$setSelection","clone","$insertNodeToNearestRoot","$getSelection","$isRangeSelection","focus","focusNode","getNode","focusOffset","offset","$isRootOrShadowRoot","focusChild","getChildAtIndex","insertBefore","selectNext","splitNode","splitOffset","$isTextNode","getParentOrThrow","getIndexWithinParent","splitText","rightTree","$splitNode","selectStart","$isNodeSelection","DEPRECATED_$isGridSelection","getNodes","getTopLevelElementOrThrow","root","paragraphNode","$createParagraphNode","select","$wrapNodeInElement","createElementNode","elementNode","replace","recurse","currentNode","isParentRoot","nodeToMove","$copyNode","leftTree","exports"],"sources":["/Users/hanauchiakiya/GitHub/re-Think/node_modules/@lexical/utils/LexicalUtils.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n\n      if (done) {\n        return resolve(processed);\n      }\n\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n\n        handleNextFile();\n      });\n\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n\n    handleNextFile();\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map(editorState._nodeMap);\n  const activeEditorState = editor._pendingEditorState;\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  lexical.$setSelection(selection === null ? null : selection.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n\n  if (startNode == null) {\n    startNode = node;\n  }\n\n  if (!!lexical.$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = lexical.$isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : lexical.$copyNode(currentNode);\n\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$splitNode = $splitNode;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}