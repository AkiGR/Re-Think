{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar list = require('@lexical/list');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return html.$generateHtmlFromNodes(editor, selection);\n} // TODO 0.6.0 Return a blank string instead\n// TODO 0.6.0 Rename to $getJSON\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      } // eslint-disable-next-line no-empty\n    } catch {}\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection); // eslint-disable-next-line no-empty\n    } catch {}\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  let list$1 = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    /**\n     * There's no good way to add this to importDOM or importJSON directly,\n     * so this is here in order to safely correct faulty clipboard data\n     * that we can't control and avoid crashing the app.\n     * https://github.com/facebook/lexical/issues/2405\n     */\n\n    if (list.$isListItemNode(node)) {\n      if (list$1 == null) {\n        list$1 = list.$createListNode('bullet');\n        topLevelBlocks.push(list$1);\n      }\n      list$1.append(node);\n      continue;\n    } else if (list$1 != null) {\n      list$1 = null;\n    }\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node)) {\n      if (currentBlock === null) {\n        currentBlock = lexical.$createParagraphNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n    anchorCell.append(...topLevelBlocks);\n  }\n}\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const newGridRowNode = newGridRows[newRowIdx];\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n    newRowIdx++;\n  }\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  const serializedChildren = serializedNode.children;\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection$1, currentNode) {\n  let targetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    serializedNode.text = target.__text;\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\nasync function copyToClipboard__EXPERIMENTAL(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const domSelection = document.getSelection();\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = document.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(document.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (secondEvent instanceof ClipboardEvent) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    document.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  const selection = lexical.$getSelection();\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;","map":{"version":3,"names":["html","require","list","selection","utils","lexical","$getHtmlContent","editor","$getSelection","Error","$isRangeSelection","isCollapsed","getNodes","length","$generateHtmlFromNodes","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","htmlString","parser","DOMParser","dom","parseFromString","$generateNodesFromDOM","lines","split","linesLength","i","insertText","insertParagraph","isSelectionInsideOfGrid","DEPRECATED_$isGridSelection","$findMatchingParent","anchor","getNode","n","DEPRECATED_$isGridCellNode","focus","DEPRECATED_$isGridNode","$mergeGridNodesStrategy","$basicInsertStrategy","topLevelBlocks","currentBlock","list$1","node","$isListItemNode","$createListNode","push","append","isLineBreakNode","$isLineBreakNode","$isDecoratorNode","isInline","$isElementNode","$isTextNode","$createParagraphNode","insertNodes","anchorCell","isFromLexical","newGrid","newGridRows","getChildren","newColumnCount","getFirstChildOrThrow","getChildrenSize","newRowCount","gridCellNode","gridRowNode","DEPRECATED_$isGridRowNode","gridNode","startY","getIndexWithinParent","stopY","Math","min","startX","stopX","fromX","fromY","toX","max","toY","gridRowNodes","newRowIdx","newAnchorCellKey","newFocusCellKey","r","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","c","currentGridCellNode","newGridCellNode","getKey","originalChildren","forEach","child","paragraphNode","remove","newGridSelection","DEPRECATED_$createGridSelection","set","$setSelection","dispatchCommand","SELECTION_CHANGE_COMMAND","undefined","exportNodeToJSON","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","selection$1","currentNode","targetArray","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","$cloneWithProperties","$sliceSelectedTextNodeContent","__text","childNode","shouldIncludeChild","extractWithChild","serializedChildNode","root","$getRoot","topLevelChildren","topLevelNode","serializedNodes","$parseSerializedNode","$addNodeStyle","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard__EXPERIMENTAL","event","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","domSelection","document","getSelection","element","createElement","style","cssText","createTextNode","range","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","COPY_COMMAND","secondEvent","ClipboardEvent","window","clearTimeout","COMMAND_PRIORITY_CRITICAL","setTimeout","execCommand","preventDefault","clipboardData","plainString","getTextContent","setData","exports"],"sources":["/Users/hanauchiakiya/GitHub/re-Think/node_modules/@lexical/clipboard/LexicalClipboard.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar list = require('@lexical/list');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n} // TODO 0.6.0 Return a blank string instead\n// TODO 0.6.0 Rename to $getJSON\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      } // eslint-disable-next-line no-empty\n\n    } catch {}\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection); // eslint-disable-next-line no-empty\n    } catch {}\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n\n\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  let list$1 = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    /**\n     * There's no good way to add this to importDOM or importJSON directly,\n     * so this is here in order to safely correct faulty clipboard data\n     * that we can't control and avoid crashing the app.\n     * https://github.com/facebook/lexical/issues/2405\n     */\n\n    if (list.$isListItemNode(node)) {\n      if (list$1 == null) {\n        list$1 = list.$createListNode('bullet');\n        topLevelBlocks.push(list$1);\n      }\n\n      list$1.append(node);\n      continue;\n    } else if (list$1 != null) {\n      list$1 = null;\n    }\n\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node)) {\n      if (currentBlock === null) {\n        currentBlock = lexical.$createParagraphNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    serializedNode.text = target.__text;\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\nasync function copyToClipboard__EXPERIMENTAL(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const domSelection = document.getSelection();\n\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n\n  const element = document.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(document.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (secondEvent instanceof ClipboardEvent) {\n        removeListener();\n\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    document.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n\n  if (clipboardData === null) {\n    return false;\n  }\n\n  const selection = lexical.$getSelection();\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard__EXPERIMENTAL = copyToClipboard__EXPERIMENTAL;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}