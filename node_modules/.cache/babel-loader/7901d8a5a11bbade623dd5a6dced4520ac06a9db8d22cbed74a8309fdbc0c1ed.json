{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n} // TODO: rewrite with $findMatchingParent or *nodeOfType\n\nfunction findNearestListItemNode(node) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isListItemNode(currentNode)) {\n      return currentNode;\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\nfunction getUniqueListItemNodes(nodeList) {\n  const keys = new Set();\n  for (let i = 0; i < nodeList.length; i++) {\n    const node = nodeList[i];\n    if ($isListItemNode(node)) {\n      keys.add(node);\n    }\n  }\n  return Array.from(keys);\n}\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n  const siblings = listItem.getPreviousSiblings();\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n  return value;\n}\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      } else {\n        const handled = new Set();\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n            while (parent != null) {\n              const parentKey = parent.getKey();\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n                break;\n              } else {\n                const nextParent = parent.getParent();\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\nfunction $handleIndent(listItemNodes) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n      return;\n    }\n    const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n    const nextSibling = listItemNode.getNextSibling();\n    const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        const nextInnerList = nextSibling.getFirstChild();\n        if ($isListNode(nextInnerList)) {\n          const children = nextInnerList.getChildren();\n          append(innerList, children);\n          nextSibling.remove();\n          removed.add(nextSibling.getKey());\n        }\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(nextSibling)) {\n      // if the ListItemNode is next to a nested ListNode, merge them\n      const innerList = nextSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        const firstChild = innerList.getFirstChild();\n        if (firstChild !== null) {\n          firstChild.insertBefore(listItemNode);\n        }\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        updateChildrenListItemValue(innerList);\n      }\n    } else {\n      // otherwise, we need to create a new nested ListNode\n      if ($isListNode(parent)) {\n        const newListItem = $createListItemNode();\n        const newList = $createListNode(parent.getListType());\n        newListItem.append(newList);\n        newList.append(listItemNode);\n        if (previousSibling) {\n          previousSibling.insertAfter(newListItem);\n        } else if (nextSibling) {\n          nextSibling.insertBefore(newListItem);\n        } else {\n          parent.append(newListItem);\n        }\n      }\n    }\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n    }\n  });\n}\nfunction $handleOutdent(listItemNodes) {\n  // go through each node and decide where to move it.\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode)) {\n      return;\n    }\n    const parentList = listItemNode.getParent();\n    const grandparentListItem = parentList ? parentList.getParent() : undefined;\n    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n      // if it's the first child in it's parent list, insert it into the\n      // great grandparent list before the grandparent\n      const firstChild = parentList ? parentList.getFirstChild() : undefined;\n      const lastChild = parentList ? parentList.getLastChild() : undefined;\n      if (listItemNode.is(firstChild)) {\n        grandparentListItem.insertBefore(listItemNode);\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        } // if it's the last child in it's parent list, insert it into the\n        // great grandparent list after the grandparent.\n      } else if (listItemNode.is(lastChild)) {\n        grandparentListItem.insertAfter(listItemNode);\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        }\n      } else {\n        // otherwise, we need to split the siblings into two new nested lists\n        const listType = parentList.getListType();\n        const previousSiblingsListItem = $createListItemNode();\n        const previousSiblingsList = $createListNode(listType);\n        previousSiblingsListItem.append(previousSiblingsList);\n        listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n        const nextSiblingsListItem = $createListItemNode();\n        const nextSiblingsList = $createListNode(listType);\n        nextSiblingsListItem.append(nextSiblingsList);\n        append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n        grandparentListItem.insertBefore(previousSiblingsListItem);\n        grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n        grandparentListItem.replace(listItemNode);\n      }\n      updateChildrenListItemValue(parentList);\n      updateChildrenListItemValue(greatGrandparentList);\n    }\n  });\n}\nfunction maybeIndentOrOutdent(direction) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n  const selectedNodes = selection.getNodes();\n  let listItemNodes = [];\n  if (selectedNodes.length === 0) {\n    selectedNodes.push(selection.anchor.getNode());\n  }\n  if (selectedNodes.length === 1) {\n    // Only 1 node selected. Selection may not contain the ListNodeItem so we traverse the tree to\n    // find whether this is part of a ListItemNode\n    const nearestListItemNode = findNearestListItemNode(selectedNodes[0]);\n    if (nearestListItemNode !== null) {\n      listItemNodes = [nearestListItemNode];\n    }\n  } else {\n    listItemNodes = getUniqueListItemNodes(selectedNodes);\n  }\n  if (listItemNodes.length > 0) {\n    if (direction === 'indent') {\n      $handleIndent(listItemNodes);\n    } else {\n      $handleOutdent(listItemNodes);\n    }\n  }\n}\nfunction indentList() {\n  maybeIndentOrOutdent('indent');\n}\nfunction outdentList() {\n  maybeIndentOrOutdent('outdent');\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(element, this, null, parent);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(dom, this, prevNode, parent);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    const list = this.getParentOrThrow();\n    if ($isListNode(list)) {\n      const childrenKeys = list.getChildrenKeys();\n      const childrenLength = childrenKeys.length;\n      const index = childrenKeys.indexOf(this.__key);\n      if (index === 0) {\n        list.insertBefore(replaceWithNode);\n      } else if (index === childrenLength - 1) {\n        list.insertAfter(replaceWithNode);\n      } else {\n        // Split the list\n        const newList = $createListNode(list.getListType());\n        const children = list.getChildren();\n        for (let i = index + 1; i < childrenLength; i++) {\n          const child = children[i];\n          newList.append(child);\n        }\n        list.insertAfter(replaceWithNode);\n        replaceWithNode.insertAfter(newList);\n      }\n      if (includeChildren) {\n        this.getChildren().forEach(child => {\n          replaceWithNode.append(child);\n        });\n      }\n      this.remove();\n      if (childrenLength === 1) {\n        list.remove();\n      }\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    const siblings = this.getNextSiblings();\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (nextSibling !== null) {\n      const parent = nextSibling.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n  insertNewAfter(_) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent([this]);\n        currentIndent++;\n      } else {\n        $handleOutdent([this]);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n  canIndent() {\n    // Indent/outdent is handled specifically in the RichText logic.\n    return false;\n  }\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n    return super.insertBefore(nodeToInsert);\n  }\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  const isCheckList = listNode.getListType() === 'check';\n  if (isCheckList) {\n    // Only add attributes for leaf list items\n    if ($isListNode(listItemNode.getFirstChild())) {\n      dom.removeAttribute('role');\n      dom.removeAttribute('tabIndex');\n      dom.removeAttribute('aria-checked');\n    } else {\n      dom.setAttribute('role', 'checkbox');\n      dom.setAttribute('tabIndex', '-1');\n      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n      }\n    }\n  } else {\n    // Clean up checked state\n    if (listItemNode.getChecked() != null) {\n      listItemNode.setChecked(undefined);\n    }\n  }\n}\nfunction convertListItemElement(domNode) {\n  const checked = domNode instanceof HTMLElement && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  } // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = document.createElement(this.__tag);\n    if (this.__start !== 1) {\n      element.setAttribute('start', String(this.__start));\n    }\n    if (this.__listType === 'check') {\n      element.setAttribute('__lexicalListType', 'check');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const currentNode = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      node.getChildren().forEach(child => {\n        if ($isListNode(child)) {\n          normalizedListItems.push(wrapInListItem(child));\n        }\n      });\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    node = $createListNode('number');\n  } else if (nodeName === 'ul') {\n    if (domNode instanceof HTMLElement && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\nfunction $createListNode(listType) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.indentList = indentList;\nexports.insertList = insertList;\nexports.outdentList = outdentList;\nexports.removeList = removeList;","map":{"version":3,"names":["lexical","require","utils","$getListDepth","listNode","depth","parent","getParent","$isListItemNode","parentList","$isListNode","Error","$getTopListNode","listItem","list","$getAllListItems","node","listItemNodes","listChildren","getChildren","filter","i","length","listItemNode","firstChild","getFirstChild","concat","push","isNestedListNode","findNearestListItemNode","currentNode","getUniqueListItemNodes","nodeList","keys","Set","add","Array","from","$removeHighestEmptyListParent","sublist","emptyListPtr","getNextSibling","getPreviousSibling","remove","wrapInListItem","listItemWrapper","$createListItemNode","append","$isSelectingEmptyListItem","anchorNode","nodes","is","getChildrenSize","$getListItemValue","value","getStart","siblings","getPreviousSiblings","sibling","insertList","editor","listType","update","selection","$getSelection","$isRangeSelection","DEPRECATED_$isGridSelection","getNodes","anchor","getNode","anchorNodeParent","$createListNode","$isRootOrShadowRoot","replace","$isElementNode","setFormat","getFormatType","setIndent","getIndent","getParentOrThrow","handled","isEmpty","has","getKey","createListOrMerge","$isLeafNode","parentKey","newListNode","updateChildrenListItemValue","nextParent","nodesToAppend","splice","previousSibling","nextSibling","getListType","getFirstChildOrThrow","insertBefore","removeList","listNodes","$getNearestNodeOfType","ListItemNode","insertionPoint","listItems","paragraph","$createParagraphNode","insertAfter","__key","key","set","focus","children","childrenOrExisting","undefined","child","prevValue","getValue","nextValue","setValue","$handleIndent","removed","forEach","innerList","nextInnerList","newListItem","newList","$handleOutdent","grandparentListItem","greatGrandparentList","lastChild","getLastChild","previousSiblingsListItem","previousSiblingsList","nextSiblingsListItem","nextSiblingsList","getNextSiblings","maybeIndentOrOutdent","direction","selectedNodes","nearestListItemNode","indentList","outdentList","$handleListInsertParagraph","isCollapsed","getTextContent","topListNode","grandparent","replacementNode","select","nextSiblings","$isParagraphNode","ElementNode","getType","clone","__value","__checked","constructor","checked","createDOM","config","element","document","createElement","updateListItemChecked","$setListItemThemeClassNames","theme","updateDOM","prevNode","dom","importDOM","li","conversion","convertListItemElement","priority","importJSON","serializedNode","format","indent","setDirection","exportJSON","getChecked","type","version","canMergeWith","replaceWithNode","includeChildren","childrenKeys","getChildrenKeys","childrenLength","index","indexOf","restoreSelection","after","afterListNode","preserveEmptyParent","insertNewAfter","_","newElement","collapseAtStart","listNodeParent","isIndented","offset","self","getLatest","getWritable","setChecked","toggleChecked","__indent","indentLevel","currentIndent","canIndent","nodeToInsert","canInsertAfter","canReplaceWith","replacement","extractWithChild","focusNode","isParentOf","editorThemeClasses","classesToAdd","classesToRemove","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","listItemClasses","split","parentNode","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","some","removeClassNamesFromElement","addClassNamesToElement","prevListItemNode","removeAttribute","setAttribute","domNode","HTMLElement","getAttribute","$applyNodeReplacement","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","start","_listType","getTag","_editor","tag","String","__lexicalListType","setListThemeClassNames","ol","convertListNode","ul","exportDOM","canBeEmpty","textNode","$createTextNode","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","normalizeChildren","normalizedListItems","nodeName","toLowerCase","INSERT_UNORDERED_LIST_COMMAND","createCommand","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND","exports"],"sources":["/Users/hanauchiakiya/GitHub/re-Think/node_modules/@lexical/list/LexicalList.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n} // TODO: rewrite with $findMatchingParent or *nodeOfType\n\nfunction findNearestListItemNode(node) {\n  let currentNode = node;\n\n  while (currentNode !== null) {\n    if ($isListItemNode(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.getParent();\n  }\n\n  return null;\n}\nfunction getUniqueListItemNodes(nodeList) {\n  const keys = new Set();\n\n  for (let i = 0; i < nodeList.length; i++) {\n    const node = nodeList[i];\n\n    if ($isListItemNode(node)) {\n      keys.add(node);\n    }\n  }\n\n  return Array.from(keys);\n}\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n\n        listNode.remove();\n      }\n    }\n  });\n}\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\nfunction $handleIndent(listItemNodes) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n      return;\n    }\n\n    const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n    const nextSibling = listItemNode.getNextSibling();\n    const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        const nextInnerList = nextSibling.getFirstChild();\n\n        if ($isListNode(nextInnerList)) {\n          const children = nextInnerList.getChildren();\n          append(innerList, children);\n          nextSibling.remove();\n          removed.add(nextSibling.getKey());\n        }\n\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(nextSibling)) {\n      // if the ListItemNode is next to a nested ListNode, merge them\n      const innerList = nextSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        const firstChild = innerList.getFirstChild();\n\n        if (firstChild !== null) {\n          firstChild.insertBefore(listItemNode);\n        }\n\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        updateChildrenListItemValue(innerList);\n      }\n    } else {\n      // otherwise, we need to create a new nested ListNode\n      if ($isListNode(parent)) {\n        const newListItem = $createListItemNode();\n        const newList = $createListNode(parent.getListType());\n        newListItem.append(newList);\n        newList.append(listItemNode);\n\n        if (previousSibling) {\n          previousSibling.insertAfter(newListItem);\n        } else if (nextSibling) {\n          nextSibling.insertBefore(newListItem);\n        } else {\n          parent.append(newListItem);\n        }\n      }\n    }\n\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n    }\n  });\n}\nfunction $handleOutdent(listItemNodes) {\n  // go through each node and decide where to move it.\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode)) {\n      return;\n    }\n\n    const parentList = listItemNode.getParent();\n    const grandparentListItem = parentList ? parentList.getParent() : undefined;\n    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n      // if it's the first child in it's parent list, insert it into the\n      // great grandparent list before the grandparent\n      const firstChild = parentList ? parentList.getFirstChild() : undefined;\n      const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n      if (listItemNode.is(firstChild)) {\n        grandparentListItem.insertBefore(listItemNode);\n\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        } // if it's the last child in it's parent list, insert it into the\n        // great grandparent list after the grandparent.\n\n      } else if (listItemNode.is(lastChild)) {\n        grandparentListItem.insertAfter(listItemNode);\n\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        }\n      } else {\n        // otherwise, we need to split the siblings into two new nested lists\n        const listType = parentList.getListType();\n        const previousSiblingsListItem = $createListItemNode();\n        const previousSiblingsList = $createListNode(listType);\n        previousSiblingsListItem.append(previousSiblingsList);\n        listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n        const nextSiblingsListItem = $createListItemNode();\n        const nextSiblingsList = $createListNode(listType);\n        nextSiblingsListItem.append(nextSiblingsList);\n        append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n        grandparentListItem.insertBefore(previousSiblingsListItem);\n        grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n        grandparentListItem.replace(listItemNode);\n      }\n\n      updateChildrenListItemValue(parentList);\n      updateChildrenListItemValue(greatGrandparentList);\n    }\n  });\n}\n\nfunction maybeIndentOrOutdent(direction) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const selectedNodes = selection.getNodes();\n  let listItemNodes = [];\n\n  if (selectedNodes.length === 0) {\n    selectedNodes.push(selection.anchor.getNode());\n  }\n\n  if (selectedNodes.length === 1) {\n    // Only 1 node selected. Selection may not contain the ListNodeItem so we traverse the tree to\n    // find whether this is part of a ListItemNode\n    const nearestListItemNode = findNearestListItemNode(selectedNodes[0]);\n\n    if (nearestListItemNode !== null) {\n      listItemNodes = [nearestListItemNode];\n    }\n  } else {\n    listItemNodes = getUniqueListItemNodes(selectedNodes);\n  }\n\n  if (listItemNodes.length > 0) {\n    if (direction === 'indent') {\n      $handleIndent(listItemNodes);\n    } else {\n      $handleOutdent(listItemNodes);\n    }\n  }\n}\n\nfunction indentList() {\n  maybeIndentOrOutdent('indent');\n}\nfunction outdentList() {\n  maybeIndentOrOutdent('outdent');\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(element, this, null, parent);\n    }\n\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(dom, this, prevNode, parent);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    const list = this.getParentOrThrow();\n\n    if ($isListNode(list)) {\n      const childrenKeys = list.getChildrenKeys();\n      const childrenLength = childrenKeys.length;\n      const index = childrenKeys.indexOf(this.__key);\n\n      if (index === 0) {\n        list.insertBefore(replaceWithNode);\n      } else if (index === childrenLength - 1) {\n        list.insertAfter(replaceWithNode);\n      } else {\n        // Split the list\n        const newList = $createListNode(list.getListType());\n        const children = list.getChildren();\n\n        for (let i = index + 1; i < childrenLength; i++) {\n          const child = children[i];\n          newList.append(child);\n        }\n\n        list.insertAfter(replaceWithNode);\n        replaceWithNode.insertAfter(newList);\n      }\n\n      if (includeChildren) {\n        this.getChildren().forEach(child => {\n          replaceWithNode.append(child);\n        });\n      }\n\n      this.remove();\n\n      if (childrenLength === 1) {\n        list.remove();\n      }\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node, restoreSelection);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent) {\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (nextSibling !== null) {\n      const parent = nextSibling.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent([this]);\n        currentIndent++;\n      } else {\n        $handleOutdent([this]);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  canIndent() {\n    // Indent/outdent is handled specifically in the RichText logic.\n    return false;\n  }\n\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  const isCheckList = listNode.getListType() === 'check';\n\n  if (isCheckList) {\n    // Only add attributes for leaf list items\n    if ($isListNode(listItemNode.getFirstChild())) {\n      dom.removeAttribute('role');\n      dom.removeAttribute('tabIndex');\n      dom.removeAttribute('aria-checked');\n    } else {\n      dom.setAttribute('role', 'checkbox');\n      dom.setAttribute('tabIndex', '-1');\n\n      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n      }\n    }\n  } else {\n    // Clean up checked state\n    if (listItemNode.getChecked() != null) {\n      listItemNode.setChecked(undefined);\n    }\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  const checked = domNode instanceof HTMLElement && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType, start, key) {\n    super(key);\n\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  getListType() {\n    return this.__listType;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor) {\n    const element = document.createElement(this.__tag);\n\n    if (this.__start !== 1) {\n      element.setAttribute('start', String(this.__start));\n    }\n\n    if (this.__listType === 'check') {\n      element.setAttribute('__lexicalListType', 'check');\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    return this;\n  }\n\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      node.getChildren().forEach(child => {\n        if ($isListNode(child)) {\n          normalizedListItems.push(wrapInListItem(child));\n        }\n      });\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n\n  return normalizedListItems;\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol') {\n    node = $createListNode('number');\n  } else if (nodeName === 'ul') {\n    if (domNode instanceof HTMLElement && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\n\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.indentList = indentList;\nexports.insertList = insertList;\nexports.outdentList = outdentList;\nexports.removeList = removeList;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}