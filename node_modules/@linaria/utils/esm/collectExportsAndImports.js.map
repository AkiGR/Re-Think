{"version":3,"file":"collectExportsAndImports.js","names":["warn","getScope","isExports","isNotNull","isRequire","isTypedNode","sideEffectImport","item","imported","explicitImport","getValue","node","type","name","value","isType","p","importKind","exportKind","collectors","ImportSpecifier","path","source","get","local","ImportDefaultSpecifier","ImportNamespaceSpecifier","unfoldNamespaceImport","collectFromImportDeclaration","state","specifiers","length","imports","push","forEach","specifier","isImportSpecifier","collector","getAncestorsWhile","cond","result","current","parentPath","whatIsDestructed","objectPattern","destructedProps","traverse","Identifier","identifier","isBindingIdentifier","parent","isObjectProperty","chain","filter","map","key","isIdentifier","reverse","what","as","isRestElement","argument","importFromVariableDeclarator","isSync","id","isObjectPattern","exportFromVariableDeclarator","init","isExpression","exported","destructed","collectFromDynamicImport","callExpression","isCallExpression","sourcePath","isStringLiteral","container","isAwaited","isAwaitExpression","isVariableDeclarator","prop","getImportTypeByInteropFunction","callee","undefined","startsWith","collectFromRequire","variableDeclarator","unfolded","isMemberExpression","property","isExpressionStatement","isChainOfVoidAssignment","right","isUnaryExpression","operator","isAssignmentExpression","getReturnValue","params","body","returnStatement","isReturnStatement","getGetterValueFromDescriptor","descriptor","getter","find","isFunctionExpression","isArrowFunctionExpression","collectFromExports","object","memberExpression","exportName","saveRef","exportRefs","has","set","assignmentExpression","left","exports","matchesPattern","obj","isObjectExpression","collectFromRequireOrExports","importItem","binding","getBinding","referenced","referencePath","referencePaths","ancestor","isTSType","isFlowType","computed","isExportSpecifier","collectFromExportAllDeclaration","reexports","collectFromExportSpecifier","isExportDefaultSpecifier","isExportNamespaceSpecifier","collectFromExportNamedDeclaration","declaration","isVariableDeclaration","declarator","isFunctionDeclaration","collectFromExportDefaultDeclaration","cache","WeakMap","collectFromAssignmentExpression","skip","collectFromExportStarCall","requireCall","collectFromMap","properties","isFunction","returnValue","collectFromEsbuildExportCall","sourceExports","collectFromEsbuildReExportCall","collectFromSwcExportCall","collectFromCallExpression","maybeExportStart","collectExportsAndImports","force","Map","AssignmentExpression","CallExpression","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ImportDeclaration","Import"],"sources":["../src/collectExportsAndImports.ts"],"sourcesContent":["/* eslint @typescript-eslint/no-use-before-define: [\"error\", { \"functions\": false }] */\n/* eslint-disable no-restricted-syntax,no-continue */\n\nimport type { NodePath } from '@babel/traverse';\nimport type {\n  AssignmentExpression,\n  BlockStatement,\n  CallExpression,\n  ExportAllDeclaration,\n  ExportDefaultDeclaration,\n  ExportDefaultSpecifier,\n  ExportNamedDeclaration,\n  ExportNamespaceSpecifier,\n  ExportSpecifier,\n  Expression,\n  Function as FunctionNode,\n  Identifier,\n  Import,\n  ImportDeclaration,\n  ImportDefaultSpecifier,\n  ImportNamespaceSpecifier,\n  ImportSpecifier,\n  MemberExpression,\n  ObjectExpression,\n  ObjectPattern,\n  StringLiteral,\n  VariableDeclarator,\n} from '@babel/types';\n\nimport { warn } from '@linaria/logger';\n\nimport { getScope } from './getScope';\nimport isExports from './isExports';\nimport isNotNull from './isNotNull';\nimport isRequire from './isRequire';\nimport isTypedNode from './isTypedNode';\n\nexport interface ISideEffectImport {\n  imported: null;\n  local: NodePath;\n  source: string;\n}\n\nexport interface IImport {\n  imported: string | 'default' | '*';\n  local: NodePath<Identifier | MemberExpression>;\n  source: string;\n  type: 'cjs' | 'dynamic' | 'esm';\n}\n\nexport interface IExport {\n  exported: string | 'default' | '*'; // '*' means re-export all\n  local: NodePath;\n}\n\nexport interface IReexport {\n  exported: string | 'default' | '*';\n  imported: string | 'default' | '*';\n  local: NodePath;\n  source: string;\n}\n\nexport interface IState {\n  exportRefs: Map<string, NodePath<MemberExpression>[]>;\n  exports: IExport[];\n  imports: (IImport | ISideEffectImport)[];\n  reexports: IReexport[];\n}\n\nexport const sideEffectImport = (\n  item: IImport | ISideEffectImport\n): item is ISideEffectImport => item.imported === null;\n\nexport const explicitImport = (\n  item: IImport | ISideEffectImport\n): item is IImport => item.imported !== null;\n\nfunction getValue({ node }: { node: Identifier | StringLiteral }): string {\n  return node.type === 'Identifier' ? node.name : node.value;\n}\n\n// We ignore imports and exports of types\nconst isType = (p: {\n  node: { importKind?: 'type' | unknown } | { exportKind?: 'type' | unknown };\n}): boolean =>\n  ('importKind' in p.node && p.node.importKind === 'type') ||\n  ('exportKind' in p.node && p.node.exportKind === 'type');\n\n// Force TypeScript to check, that we have implementation for every possible specifier\ntype SpecifierTypes = ImportDeclaration['specifiers'][number];\nconst collectors: {\n  [K in SpecifierTypes['type']]: (\n    path: NodePath<SpecifierTypes & { type: K }>,\n    source: string\n  ) => IImport[];\n} = {\n  ImportSpecifier(path: NodePath<ImportSpecifier>, source): IImport[] {\n    if (isType(path)) return [];\n    const imported = getValue(path.get('imported'));\n    const local = path.get('local');\n    return [{ imported, local, source, type: 'esm' }];\n  },\n\n  ImportDefaultSpecifier(\n    path: NodePath<ImportDefaultSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return [{ imported: 'default', local, source, type: 'esm' }];\n  },\n\n  ImportNamespaceSpecifier(\n    path: NodePath<ImportNamespaceSpecifier>,\n    source\n  ): IImport[] {\n    const local = path.get('local');\n    return unfoldNamespaceImport({ imported: '*', local, source, type: 'esm' });\n  },\n};\n\nfunction collectFromImportDeclaration(\n  path: NodePath<ImportDeclaration>,\n  state: IState\n): void {\n  // If importKind is specified, and it's not a value, ignore that import\n  if (isType(path)) return;\n\n  const source = getValue(path.get('source'));\n  const specifiers = path.get('specifiers');\n\n  if (specifiers.length === 0) {\n    state.imports.push({ imported: null, local: path, source });\n  }\n\n  specifiers.forEach(<T extends SpecifierTypes>(specifier: NodePath<T>) => {\n    if (specifier.isImportSpecifier() && isType(specifier)) return;\n\n    const collector = collectors[\n      specifier.node.type\n    ] as typeof collectors[T['type']];\n\n    state.imports.push(...collector(specifier, source));\n  });\n}\n\ninterface IDestructed {\n  what: string | '*';\n  as: NodePath<Identifier>;\n}\n\nfunction getAncestorsWhile(path: NodePath, cond: (p: NodePath) => boolean) {\n  const result: NodePath[] = [];\n  let current: NodePath | null = path;\n  while (current && cond(current)) {\n    result.push(current);\n    current = current.parentPath;\n  }\n\n  return result;\n}\n\nfunction whatIsDestructed(\n  objectPattern: NodePath<ObjectPattern>\n): IDestructed[] {\n  const destructedProps: IDestructed[] = [];\n  objectPattern.traverse({\n    Identifier(identifier) {\n      if (identifier.isBindingIdentifier()) {\n        const parent = identifier.parentPath;\n        if (parent.isObjectProperty({ value: identifier.node })) {\n          const chain = getAncestorsWhile(parent, (p) => p !== objectPattern)\n            .filter(isTypedNode('ObjectProperty'))\n            .map((p) => {\n              const key = p.get('key');\n              if (!key.isIdentifier()) {\n                // TODO: try to process other type of keys or at least warn about this\n                return null;\n              }\n\n              return key;\n            })\n            .filter(isNotNull);\n          chain.reverse();\n\n          if (chain.length > 0) {\n            destructedProps.push({\n              what: chain[0].node.name,\n              as: identifier,\n            });\n          }\n\n          return;\n        }\n\n        if (parent.isRestElement({ argument: identifier.node })) {\n          destructedProps.push({\n            what: '*',\n            as: identifier,\n          });\n        }\n      }\n    },\n  });\n\n  return destructedProps;\n}\n\nfunction importFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>,\n  isSync: boolean\n): IDestructed[] {\n  const id = path.get('id');\n  if (id.isIdentifier()) {\n    // It's the simplest case when the full namespace is imported\n    return [\n      {\n        as: id,\n        what: '*',\n      },\n    ];\n  }\n\n  if (!isSync) {\n    // Something went wrong\n    // Is it something like `const { … } = import(…)`?\n    warn('evaluator:collectExportsAndImports', '`import` should be awaited');\n    return [];\n  }\n\n  if (id.isObjectPattern()) {\n    return whatIsDestructed(id);\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports:importFromVariableDeclarator',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction exportFromVariableDeclarator(\n  path: NodePath<VariableDeclarator>\n): IExport[] {\n  const id = path.get('id');\n  const init = path.get('init');\n\n  // If there is no init expression, we can ignore this export\n  if (!init || !init.isExpression()) return [];\n\n  if (id.isIdentifier()) {\n    // It is `export const a = 1;`\n    return [\n      {\n        local: init,\n        exported: id.node.name,\n      },\n    ];\n  }\n\n  if (id.isObjectPattern()) {\n    // It is `export const { a, ...rest } = obj;`\n    return whatIsDestructed(id).map((destructed) => ({\n      local: init,\n      exported: destructed.as.node.name,\n    }));\n  }\n\n  // What else it can be?\n  warn(\n    'evaluator:collectExportsAndImports:exportFromVariableDeclarator',\n    'Unknown type of id',\n    id.node.type\n  );\n\n  return [];\n}\n\nfunction collectFromDynamicImport(path: NodePath<Import>, state: IState): void {\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `import`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  let { parentPath: container, key } = callExpression;\n  let isAwaited = false;\n\n  if (container.isAwaitExpression()) {\n    // If it's not awaited import, it imports the full namespace\n    isAwaited = true;\n    key = container.key;\n    container = container.parentPath!;\n  }\n\n  // Is it `const something = await import(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, isAwaited).map((prop) =>\n      state.imports.push({\n        imported: prop.what,\n        local: prop.as,\n        source,\n        type: 'dynamic',\n      })\n    );\n  }\n}\n\nfunction getImportTypeByInteropFunction(\n  path: NodePath<CallExpression>\n): '*' | 'default' | undefined {\n  const callee = path.get('callee');\n  if (!callee.isIdentifier()) {\n    return undefined;\n  }\n\n  const { name } = callee.node;\n  if (\n    name.startsWith('_interopRequireDefault') ||\n    name.startsWith('__importDefault')\n  ) {\n    return 'default';\n  }\n\n  if (\n    name.startsWith('_interopRequireWildcard') ||\n    name.startsWith('__importStar') ||\n    name.startsWith('__toESM')\n  ) {\n    return '*';\n  }\n\n  if (\n    name.startsWith('__rest') ||\n    name.startsWith('__objRest') ||\n    name.startsWith('_objectDestructuringEmpty')\n  ) {\n    return '*';\n  }\n\n  return undefined;\n}\n\nfunction collectFromRequire(path: NodePath<Identifier>, state: IState): void {\n  if (!isRequire(path)) return;\n\n  const { parentPath: callExpression } = path;\n  if (!callExpression.isCallExpression()) {\n    // It's wrong `require`\n    return;\n  }\n\n  const [sourcePath] = callExpression.get('arguments');\n  if (!sourcePath || !sourcePath.isStringLiteral()) {\n    // Import should have at least one argument, and it should be StringLiteral\n    return;\n  }\n\n  const source = sourcePath.node.value;\n\n  const { parentPath: container, key } = callExpression;\n\n  if (container.isCallExpression() && key === 0) {\n    // It may be transpiled import such as\n    // `var _atomic = _interopRequireDefault(require(\"@linaria/atomic\"));`\n    const imported = getImportTypeByInteropFunction(container);\n    if (!imported) {\n      // It's not a transpiled import.\n      // TODO: Can we guess that it's a namespace import?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unknown wrapper of require',\n        container.node.callee\n      );\n      return;\n    }\n\n    let { parentPath: variableDeclarator } = container;\n    if (variableDeclarator.isCallExpression()) {\n      if (variableDeclarator.get('callee').isIdentifier({ name: '_extends' })) {\n        variableDeclarator = variableDeclarator.parentPath!;\n      }\n    }\n\n    if (!variableDeclarator.isVariableDeclarator()) {\n      // TODO: Where else it can be?\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Unexpected require inside',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    const id = variableDeclarator.get('id');\n    if (!id.isIdentifier()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Id should be Identifier',\n        variableDeclarator.node.type\n      );\n      return;\n    }\n\n    if (imported === '*') {\n      const unfolded = unfoldNamespaceImport({\n        imported,\n        local: id,\n        source,\n        type: 'cjs',\n      });\n      state.imports.push(...unfolded);\n    } else {\n      state.imports.push({\n        imported,\n        local: id,\n        source,\n        type: 'cjs',\n      });\n    }\n  }\n\n  if (container.isMemberExpression()) {\n    // It is `require('@linaria/shaker').dep`\n    const property = container.get('property');\n    if (!property.isIdentifier() && !property.isStringLiteral()) {\n      warn(\n        'evaluator:collectExportsAndImports',\n        'Property should be Identifier or StringLiteral',\n        property.node.type\n      );\n\n      return;\n    }\n\n    const { parentPath: variableDeclarator } = container;\n\n    if (variableDeclarator.isVariableDeclarator()) {\n      // It is `const … = require('@linaria/shaker').dep`;\n      const id = variableDeclarator.get('id');\n      if (id.isIdentifier()) {\n        state.imports.push({\n          imported: getValue(property),\n          local: id,\n          source,\n          type: 'cjs',\n        });\n      } else {\n        warn(\n          'evaluator:collectExportsAndImports',\n          'Id should be Identifier',\n          variableDeclarator.node.type\n        );\n      }\n    } else {\n      // Maybe require is passed as an argument to some function?\n      // Just use the whole MemberExpression as a local\n      state.imports.push({\n        imported: getValue(property),\n        local: container,\n        source,\n        type: 'cjs',\n      });\n    }\n\n    return;\n  }\n\n  // Is it `const something = require(\"something\")`?\n  if (key === 'init' && container.isVariableDeclarator()) {\n    importFromVariableDeclarator(container, true).forEach((prop) => {\n      if (prop.what === '*') {\n        const unfolded = unfoldNamespaceImport({\n          imported: '*',\n          local: prop.as,\n          source,\n          type: 'cjs',\n        });\n\n        state.imports.push(...unfolded);\n      } else {\n        state.imports.push({\n          imported: prop.what,\n          local: prop.as,\n          source,\n          type: 'cjs',\n        });\n      }\n    });\n  }\n\n  if (container.isExpressionStatement()) {\n    // Looks like standalone require\n    state.imports.push({\n      imported: null,\n      local: container,\n      source,\n    });\n  }\n}\n\nfunction isChainOfVoidAssignment(\n  path: NodePath<AssignmentExpression>\n): boolean {\n  const right = path.get('right');\n  if (right.isUnaryExpression({ operator: 'void' })) {\n    return true;\n  }\n\n  if (right.isAssignmentExpression()) {\n    return isChainOfVoidAssignment(right);\n  }\n\n  return false;\n}\n\nfunction getReturnValue(\n  path: NodePath<FunctionNode>\n): NodePath<Expression> | undefined {\n  if (path.node.params.length !== 0) return undefined;\n\n  const body = path.get('body') as\n    | NodePath<BlockStatement>\n    | NodePath<Expression>;\n  if (body.isExpression()) {\n    return body;\n  }\n\n  if (body.node.body.length === 1) {\n    const returnStatement = body.get('body')?.[0];\n    if (!returnStatement.isReturnStatement()) return undefined;\n    const argument = returnStatement.get('argument');\n    if (!argument.isExpression()) return undefined;\n    return argument;\n  }\n\n  return undefined;\n}\n\nfunction getGetterValueFromDescriptor(\n  descriptor: NodePath<ObjectExpression>\n): NodePath<Expression> | undefined {\n  const getter = descriptor\n    .get('properties')\n    .filter(isTypedNode('ObjectProperty'))\n    .find((p) => p.get('key').isIdentifier({ name: 'get' }));\n  const value = getter?.get('value');\n\n  if (value?.isFunctionExpression() || value?.isArrowFunctionExpression()) {\n    return getReturnValue(value);\n  }\n\n  return undefined;\n}\n\nfunction collectFromExports(path: NodePath<Identifier>, state: IState): void {\n  if (!isExports(path)) return;\n\n  if (path.parentPath.isMemberExpression({ object: path.node })) {\n    // It is `exports.prop = …`\n    const memberExpression = path.parentPath;\n    const property = memberExpression.get('property');\n    if (!property.isIdentifier()) {\n      return;\n    }\n\n    const exportName = property.node.name;\n\n    const saveRef = () => {\n      // Save all export.____ usages for later\n      if (!state.exportRefs.has(exportName)) {\n        state.exportRefs.set(exportName, []);\n      }\n\n      state.exportRefs.get(exportName)!.push(memberExpression);\n    };\n\n    const assignmentExpression = memberExpression.parentPath;\n\n    if (\n      !assignmentExpression.isAssignmentExpression({\n        left: memberExpression.node,\n      })\n    ) {\n      // If it's not `exports.prop = …`. Just save it.\n      saveRef();\n      return;\n    }\n\n    const right = assignmentExpression.get('right');\n\n    if (isChainOfVoidAssignment(assignmentExpression)) {\n      // It is `exports.foo = void 0`\n      return;\n    }\n\n    const { name } = property.node;\n    if (name === '__esModule') {\n      return;\n    }\n\n    saveRef();\n    state.exports.push({ exported: property.node.name, local: right });\n\n    return;\n  }\n\n  if (\n    path.parentPath.isCallExpression() &&\n    path.parentPath.get('callee').matchesPattern('Object.defineProperty')\n  ) {\n    const [obj, prop, descriptor] = path.parentPath.get('arguments');\n    if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isStringLiteral() &&\n      prop.node.value !== '__esModule' &&\n      descriptor?.isObjectExpression()\n    ) {\n      /**\n       *  Object.defineProperty(exports, \"token\", {\n       *    enumerable: true,\n       *    get: function get() {\n       *      return _unknownPackage.token;\n       *    }\n       *  });\n       */\n      const exported = prop.node.value;\n      const local = getGetterValueFromDescriptor(descriptor);\n      if (local) {\n        state.exports.push({ exported, local });\n      }\n    } else if (\n      obj?.isIdentifier(path.node) &&\n      prop?.isIdentifier() &&\n      descriptor?.isObjectExpression()\n    ) {\n      /**\n       *  Object.defineProperty(exports, key, {\n       *    enumerable: true,\n       *    get: function get() {\n       *      return _unknownPackage[key];\n       *    }\n       *  });\n       */\n      const local = getGetterValueFromDescriptor(descriptor);\n      if (local) {\n        state.exports.push({ exported: '*', local });\n      }\n    }\n  }\n}\n\nfunction collectFromRequireOrExports(\n  path: NodePath<Identifier>,\n  state: IState\n): void {\n  if (isRequire(path)) {\n    collectFromRequire(path, state);\n  } else if (isExports(path)) {\n    collectFromExports(path, state);\n  }\n}\n\nfunction unfoldNamespaceImport(\n  importItem: IImport & { imported: '*' }\n): IImport[] {\n  const result: IImport[] = [];\n  const { local } = importItem;\n  if (!local.isIdentifier()) {\n    // TODO: handle it\n    return [importItem];\n  }\n\n  const binding = getScope(local).getBinding(local.node.name);\n  if (!binding?.referenced) {\n    // Imported namespace is not referenced and probably not used,\n    // but it can have side effects, so we should keep it as is\n    return [importItem];\n  }\n\n  for (const referencePath of binding?.referencePaths ?? []) {\n    if (\n      referencePath.find(\n        (ancestor) => ancestor.isTSType() || ancestor.isFlowType()\n      )\n    ) {\n      continue;\n    }\n\n    const { parentPath } = referencePath;\n    if (parentPath?.isMemberExpression() && referencePath.key === 'object') {\n      const property = parentPath.get('property');\n      const object = parentPath.get('object');\n      let imported: string | null;\n      if (parentPath.node.computed && property.isStringLiteral()) {\n        imported = property.node.value;\n      } else if (!parentPath.node.computed && property.isIdentifier()) {\n        imported = property.node.name;\n      } else {\n        imported = null;\n      }\n\n      if (object.isIdentifier() && imported) {\n        result.push({\n          ...importItem,\n          imported,\n          local: parentPath,\n        });\n      } else {\n        result.push(importItem);\n        break;\n      }\n\n      continue;\n    }\n\n    if (parentPath?.isVariableDeclarator() && referencePath.key === 'init') {\n      importFromVariableDeclarator(parentPath, true).map((prop) =>\n        result.push({ ...importItem, imported: prop.what, local: prop.as })\n      );\n\n      continue;\n    }\n\n    if (parentPath?.isExportSpecifier()) {\n      // The whole namespace is re-exported\n      result.push(importItem);\n      break;\n    }\n\n    // Otherwise, we can't predict usage and import it as is\n    // TODO: handle more cases\n    warn(\n      'evaluator:collectExportsAndImports:unfoldNamespaceImports',\n      'Unknown reference',\n      referencePath.node.type\n    );\n    result.push(importItem);\n    break;\n  }\n\n  return result;\n}\n\nfunction collectFromExportAllDeclaration(\n  path: NodePath<ExportAllDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n  const source = path.get('source')?.node?.value;\n  if (!source) return;\n\n  // It is `export * from './css';`\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n}\n\nfunction collectFromExportSpecifier(\n  path: NodePath<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >,\n  source: string | undefined,\n  state: IState\n): void {\n  if (path.isExportSpecifier()) {\n    const exported = getValue(path.get('exported'));\n    if (source) {\n      // It is `export { foo } from './css';`\n      const imported = path.get('local').node.name;\n      state.reexports.push({\n        exported,\n        imported,\n        local: path,\n        source,\n      });\n    } else {\n      const local = path.get('local');\n      state.exports.push({ local, exported });\n    }\n\n    return;\n  }\n\n  if (path.isExportDefaultSpecifier() && source) {\n    // It is `export default from './css';`\n    state.reexports.push({\n      exported: 'default',\n      imported: 'default',\n      local: path,\n      source,\n    });\n  }\n\n  if (path.isExportNamespaceSpecifier() && source) {\n    const exported = path.get('exported').node.name;\n    // It is `export * as foo from './css';`\n    state.reexports.push({\n      exported,\n      imported: '*',\n      local: path,\n      source,\n    });\n  }\n\n  // TODO: handle other cases\n  warn(\n    'evaluator:collectExportsAndImports:collectFromExportSpecifier',\n    'Unprocessed ExportSpecifier',\n    path.node.type\n  );\n}\n\nfunction collectFromExportNamedDeclaration(\n  path: NodePath<ExportNamedDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n\n  const source = path.get('source')?.node?.value;\n  const specifiers = path.get('specifiers');\n  if (specifiers) {\n    specifiers.forEach((specifier) =>\n      collectFromExportSpecifier(specifier, source, state)\n    );\n  }\n\n  const declaration = path.get('declaration');\n  if (declaration.isVariableDeclaration()) {\n    declaration.get('declarations').forEach((declarator) => {\n      exportFromVariableDeclarator(declarator).forEach((prop) => {\n        // What is defined\n        state.exports.push(prop);\n      });\n    });\n  }\n\n  if (declaration.isFunctionDeclaration()) {\n    const id = declaration.get('id');\n    if (id.isIdentifier()) {\n      state.exports.push({\n        exported: id.node.name,\n        local: id,\n      });\n    }\n  }\n}\n\nfunction collectFromExportDefaultDeclaration(\n  path: NodePath<ExportDefaultDeclaration>,\n  state: IState\n): void {\n  if (isType(path)) return;\n\n  const declaration = path.get('declaration');\n  state.exports.push({ exported: 'default', local: declaration });\n}\n\nconst cache = new WeakMap<NodePath, IState>();\n\nfunction collectFromAssignmentExpression(\n  path: NodePath<AssignmentExpression>,\n  state: IState\n): void {\n  const left = path.get('left');\n  const right = path.get('right');\n\n  let exported: IReexport['exported'] | undefined;\n\n  if (left.isMemberExpression() && isExports(left.get('object'))) {\n    const property = left.get('property');\n    if (property.isIdentifier()) {\n      exported = property.node.name;\n    }\n  } else if (isExports(left)) {\n    exported = '*'; // maybe\n  }\n\n  if (!exported) return;\n\n  if (!right.isCallExpression() || !isRequire(right.get('callee'))) return;\n\n  const sourcePath = right.get('arguments')?.[0];\n  const source = sourcePath.isStringLiteral()\n    ? sourcePath.node.value\n    : undefined;\n  if (!source) return;\n\n  // It is `exports.foo = require('./css');`\n\n  state.reexports.push({\n    exported,\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nfunction collectFromExportStarCall(\n  path: NodePath<CallExpression>,\n  state: IState\n) {\n  const [requireCall, exports] = path.get('arguments');\n  if (!isExports(exports)) return;\n  if (!requireCall.isCallExpression()) return;\n  const callee = requireCall.get('callee');\n  const sourcePath = requireCall.get('arguments')?.[0];\n  if (!isRequire(callee) || !sourcePath.isStringLiteral()) return;\n\n  const source = sourcePath.node.value;\n  if (!source) return;\n\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source,\n  });\n\n  path.skip();\n}\n\nfunction collectFromMap(map: NodePath<ObjectExpression>, state: IState) {\n  const properties = map.get('properties');\n  properties.forEach((property) => {\n    if (!property.isObjectProperty()) return;\n    const key = property.get('key');\n    const value = property.get('value');\n    if (!key.isIdentifier()) return;\n    const exported = key.node.name;\n\n    if (!value.isFunction()) return;\n    if (value.node.params.length !== 0) return;\n\n    const returnValue = getReturnValue(value);\n    if (!returnValue) return;\n\n    state.exports.push({\n      exported,\n      local: returnValue,\n    });\n  });\n}\n\nfunction collectFromEsbuildExportCall(\n  path: NodePath<CallExpression>,\n  state: IState\n) {\n  const [sourceExports, map] = path.get('arguments');\n  if (!sourceExports.isIdentifier({ name: 'source_exports' })) return;\n  if (!map.isObjectExpression()) return;\n\n  collectFromMap(map, state);\n\n  path.skip();\n}\n\nfunction collectFromEsbuildReExportCall(\n  path: NodePath<CallExpression>,\n  state: IState\n) {\n  const [sourceExports, requireCall, exports] = path.get('arguments');\n  if (!sourceExports.isIdentifier({ name: 'source_exports' })) return;\n  if (!requireCall.isCallExpression()) return;\n  if (!isExports(exports)) return;\n\n  const callee = requireCall.get('callee');\n  if (!isRequire(callee)) return;\n  const sourcePath = requireCall.get('arguments')?.[0];\n  if (!sourcePath.isStringLiteral()) return;\n\n  state.reexports.push({\n    exported: '*',\n    imported: '*',\n    local: path,\n    source: sourcePath.node.value,\n  });\n\n  path.skip();\n}\n\nfunction collectFromSwcExportCall(\n  path: NodePath<CallExpression>,\n  state: IState\n) {\n  const [exports, map] = path.get('arguments');\n  if (!isExports(exports)) return;\n  if (!map.isObjectExpression()) return;\n\n  collectFromMap(map, state);\n\n  path.skip();\n}\n\nfunction collectFromCallExpression(\n  path: NodePath<CallExpression>,\n  state: IState\n) {\n  const maybeExportStart = path.get('callee');\n  if (!maybeExportStart.isIdentifier()) {\n    return;\n  }\n\n  const { name } = maybeExportStart.node;\n\n  // TypeScript\n  if (name.startsWith('__exportStar')) {\n    collectFromExportStarCall(path, state);\n    return;\n  }\n\n  // swc\n  if (name === '_exportStar') {\n    collectFromExportStarCall(path, state);\n  }\n\n  if (name === '_export') {\n    collectFromSwcExportCall(path, state);\n  }\n\n  // esbuild\n  if (name === '__export') {\n    collectFromEsbuildExportCall(path, state);\n  }\n\n  if (name === '__reExport') {\n    collectFromEsbuildReExportCall(path, state);\n  }\n}\n\nexport default function collectExportsAndImports(\n  path: NodePath,\n  force = false\n): IState {\n  const state: IState = {\n    exportRefs: new Map(),\n    exports: [],\n    imports: [],\n    reexports: [],\n  };\n\n  if (!force && cache.has(path)) {\n    return cache.get(path) ?? state;\n  }\n\n  path.traverse(\n    {\n      AssignmentExpression: collectFromAssignmentExpression,\n      CallExpression: collectFromCallExpression,\n      ExportAllDeclaration: collectFromExportAllDeclaration,\n      ExportDefaultDeclaration: collectFromExportDefaultDeclaration,\n      ExportNamedDeclaration: collectFromExportNamedDeclaration,\n      ImportDeclaration: collectFromImportDeclaration,\n      Import: collectFromDynamicImport,\n      Identifier: collectFromRequireOrExports,\n    },\n    state\n  );\n\n  cache.set(path, state);\n\n  return state;\n}\n"],"mappings":"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"}